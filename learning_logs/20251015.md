## React Hook

Hook 개념은 React version 16.8 부터 도입됨. 얘를 이용하면 함수 컴포넌트에서 상태와 리액트의 다른 기능을 이용 가능(예전에는 class 컴포넌트 방식으로만 가능했음).
얘가 Hook 이라는 것을 명시하기 위한 중요한 규칙들이 몇 가지가 있음.

1. 리액트 함수 컴포넌트의 최상위 수준에서 Hook을 호출해야함.
2. 반복문, 조건문, 중첩 함수 내에서 훅을 호출해서는 안됨(1을 풀이한 것)
3. Hook은 함수기 때문에 동사로 시작하는데, use로 시작하고, 그 뒤에 훅을 사용하는 목적이 따라옴.

### useState

1. Counter 라는 컴포넌트를 생성
2. App.jsx의 return 부분을 전부 다 비우고 Count 컴포넌트만 삽입하시오.
3. Count 컴포넌트의 return문은

```jsx
return <div></div>;
```

으로 고정

```jsx
import { useState } from "react";

function Counter() {
  // 초기값이 0인 상태를 선언.
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>버튼 클릭 횟수 = {count} </p>
      <button onClick={() => setCount(count + 1)}>증가</button>
    </div>
  );
}

export default Counter;
```

- 참고 사항
  html 태그 내에서의onclick은 전체 소문자인데 반해서 React 상에서의 _이벤트 이름_ 은 카멜케이스로 작성해야함 -> onClick

함수는 이벤트 핸들러에 전달되어야 하며, 사용자가 버튼을 클릭할 때만 함수를 호출한다는 점을 기억해야함
이상의 경우 화살표 함수를 사용했는데, 이는 코드를 더 압축적으로 사용할 수 있으며, 그에 따라 코드 가독성이 개선되기 때문
그런데 이벤트 핸들러 안에서 함수를 호출하면 컴포넌트가 랜더링될 때 함수가 호출되어 무한 루프가 발생할 가능성이 있음

```jsx
// 함수가 버튼을 눌렀을 때에 호출되는 예시
// 함수를 넣은 것
<button onClick={() => setCount(count+1)}></button>

// 함수가 렌더링 중에 호출되는 예시 -> 무한 루프 걸릴 가능성 있음
// 렌더링이 되자마자 1이 증가하는 것. 값이 바뀌면 렌더링을 일어남. 1로 값이 바껴서 리랜더링이 일어남 -> 또 바로 1이 증가 -> 다시 랜더링 -> 무한루프
// 함수의 결과값을 집어넣었기 때문에 무한 루프가 일어난다.
<button onClick={setCount(count+1)}>증가 {count}</button>
```

const count = 0;
console.log(count); // 결과값이 0
count = setCount(count+1) // 이 부분에서 1이라는 값이 count 상수에 대입되었다고 볼 수 있음
console.log(count) // 결과값이 1

### 일괄 처리(Batching)

React 상에서는 상태 업데이트에서 일괄처리를 이용하여 리렌더링을 줄입니다. React 18 이전에는 일괄 처리가 버튼 클릭과 같은 브라우저 이벤트 중에 업데이트 되는 상태에서만 가능했었음.

1. MyComponent3 생성
2. App에 MyComponent3 컴포넌트를 삽입하여 main -> App -> MyComponent3로 이어지는 Tree Structure로 구현하여, npm run dev를 실행 시켜 빈 화면을 띄우시오.
3. count / count2 라는 상태(State)를 선언하고, 각 값을 0으로 초기화하시오.
4. return 문은 이하와 같습니다.

```jsx
return (
  <>
    <p>현재 값 : {count} ⭐ {count2}</p>
    <button onClick={}>증가</button>
  </>
);
```

```jsx
import "./App.css";
import { useState } from "react";

function MyComponent3() {
  const [count, setCount] = useState(0);
  const [count2, setCount2] = useState(0);

  // count, count2 한번에 증가시키는 함수
  const increment = () => {
    setCount(count + 1); // 얘가 먼저 호출될거니까 얘의 상태가 바뀔 때 리랜더링이 일어나야하지 않는가
    setCount2(count2 + 1); // 사실은 얘까지 호출되고 나서 랜더링은 한번만 일어난다.
    // 전체 함수가 호출 된 후에 변경된 값이 있으면 랜더링을 한번만 함.
  };

  return (
    <>
      <p>
        현재 값 : {count} ⭐ {count2}
      </p>
      <button onClick={increment}>증가</button>
    </>
  );
}

export default MyComponent3;
```

이상까지의 정리를 바탕으로 했을 때, Counter 컴포넌트에 이하와 같이 increment 함수를 정의한다면, 버튼을 한 번 눌렀을 때 +5씩 증가하는 것이 아니라 +1씩 증가함. 일괄처리를 한다고 보면, 값이 +1씩 다섯번이 이루어지는게 아니라 적어도 +5가 한 번에 되어야한다는 것을 의미함.

근데 +1이 한 번만 적용되는 결과가 나왔음. 여기에 주목

상태 업데이트는 일괄처리의 개념과 함께 *비동기적으로*이루어진다는 점에 주목해야함

랜더링을 하는 시점에서 값이 업데이트 됨
즉, 상태 업데이트 이전에 그 다음 함수가 호출되어버렸기 때문에
count = 0인 상태에서 +1 하기 전에 그 다음 setCount()가 호출되었기 때문에 여전히 count의 값이 0에서 +1 한 값이 나오려고 했는데 또 그 값이 업데이트 되기 이전에 다음 함수가 호출되고 ... \*5 하는 바람에 결과적으로 버튼 한 번 눌렀을 때 0+1에 해당하는 함수가 다섯번 호출되어 결과값이 1이 나옴.

```jsx
import { useState } from "react";

function Counter() {
  // 초기값이 0인 상태를 선언.
  const [count, setCount] = useState(0);

  // 이렇게 하면 +5가 아니라 +1씩 됨
  const increment = () => {
    setCount(count + 1); // count+1은 했지만 랜더링이 바로 일어나지 않음. 그래서 값이 저장(변경)되지 않음
    setCount(count + 1); // 그래서 여기서 count가 1인 상태가 아니라 여전히 0. 또 다시 0 + 1 이 됨.
    setCount(count + 1);
    setCount(count + 1);
    setCount(count + 1); // 5번 반복. 여기서도 0 + 1이 되므로 결과적으로 버튼을 눌렀을 때 +1이 된 것만 리랜더링 됨.
  };

  return (
    <div>
      <p>버튼 클릭 횟수 = {count} </p>
      <button onClick={increment}>증가</button>
    </div>
  );
}

export default Counter;
```

그렇다면 이상의 문제를 해결하기 위해서는 상태 값을 명확하게 조회한 값에서 +1을 시켜주면 됨

해당 방법이

```jsx
const increment = () => {
  setCount((preCount) => preCount + 1); // 초기값이 0인 매개변수를 받아서 +1을 하고 값을 저장
  setCount((preCount) => preCount + 1); // 여기선 0이 아니라 1이 저장된 값.
  setCount((preCount) => preCount + 1);
  setCount((preCount) => preCount + 1);
  setCount((preCount) => preCount + 1);
};
```

이상 처럼 매개변수를 추가해주게 된다면, 무조건 (최신화 된) count 값을 조회를 해야만 하기 때문에, +5가 이루어진다고 담보할 수 있게 됨.
매개변수의 이름을 바꾸더라도 count에 값이 저장됨.

그래서 여기까지 진행해주게 되면 vite project를 생성했을 때의 default onClick 형태로 함수가 작성되게 된다.

### useEffect

- useEffect는 React 함수 컴포넌트에서 보조 작업을 수행하는데 이용할 수 있다. 그리고 대부분의 경우에는 fetch 요청. 얘의 형식이 중요.
- 형식 :

```jsx
useEffect(callback, [dependencies]);
```

callback 함수에는 보조 작업 로직이 포함되어있음 (즉 argument가 함수이기 때문에 arrow function의 작성 요령이 거의 필수적). 그리고 두번째 `[dependencies]`는 의존성을 포함하는 배열로, 선택 사항에 해당. 근데 `[]`로 쓰는 경우들이 있는데 그에 대한 해석이 필요함.

1. Counter2 Component를 생성
2. App Component 내에 Counter2 컴포넌트를 삽입해줌
3. return 구조는 이하와 같음

```jsx
return (
  <>
    <p>Counter2 : {count}</p>
    <button onClick={() => setCount((preCount) => preCount + 1)}>증가</button>
  </>
);
```

4. 이상을 보면 아시겠지만 count를 상태로 선언해야함. 초기값을 0

```jsx
import "./App.css";
import { useEffect, useState } from "react";

function Counter2() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("Hello ! Change the state, count !");
  }, []);

  return (
    <>
      <p>Counter2 : {count}</p>
      <button onClick={() => setCount((preCount) => preCount + 1)}>증가</button>
    </>
  );
}

export default Counter2;
```

이상의 컴포넌트가 App에 포함되었을 때, useEffect의 두 번째 argument의 `[]`의 유무, 혹은 내부 element의 유무에 따라 콘솔창에서 str이 출력되는 횟수 및 방식이 바뀐다는 것을 확인할 수 있다.

- 이상에서 알 수 있는 점
  1. `[]`은 optional이다.(즉, method overloading의 개념이 jsx에도 여전히 존재한다)
  2. `[]`를 빈 배열로 뒀을 때는 한 번만 콘솔창에 값이 출력되었다(strictMode에서는 두번)
  3. `[count]`였을 경우에는 `[]`가 없을 때처럼 버튼을 누를 때마다 콘솔에 str이 출력되었다.

잘 생각해보면 Component가 함수형으로 이루어져있다. 즉, 렌더링이 일어날 때마다 App 컴포넌트는 Counter2 컴포넌트를 _호출_ 한다고 할 수 있음.
마참가지로 Counter2는 useEffect() 함수를 _호출_ 함. 그렇다면 호출될 때마다 콘솔에 str이 찍혀야 할 것 같은데, 2번 상태에서는 호출되지 않았다는 점도 문제가 될 수 있음.

그러면 정리했을 때, Counter2가 호출되었을 때 useEffect는 호출됨. 다만, 두 번째 argument에 따라서 첫 번째 argument인 callback function이 선택적으로 호출됨.
그러면 1, 3 에서는 계속 찍혀나오는데, 근본적인 해석이 좀 차이가 남

- `[]`가 없는 경우 : 랜더링이 일어날 때마다 callback function을 호출.(그러면 count 값이 바뀔때마다 callback함수가 호출됨)
- `[count]`로 작성한 경우 : count 값이 바뀔 때마다 callback function을 호출
- `[]`로 작성하는 경우 : 첫 번째 렌더링 시에만.

useEffect() 훅에는 콜백 함수가 모든 렌더링에서 실행되지 않게 하는 데 이용할 수 있는 두 번째 optional argument인 배열이 존재. count 값 혹은 count2를 통해서 통제했음. 즉 `[count]`라면 count 값의 변화(즉, 상태의 변화)가 있을 때마다 useEffect의 callback 함수가 호출되도록 정의

그리고 `[]`라면, useEffect()의 callback 함수는 첫번째 랜더링 후에만 실행됨.

그리고 이하의 예시에서는 useEffect()가 모든 보조 작업(callback 함수) 이전에 실행되는 정리 함수를 return 하는 것도 가능함. 이 메커니즘을 이용하면, 다음 번에 보조 작업을 실행하기 전에 이전 렌더링에서 각 효과를 정리하는 것이 가능. 보통은 구독, 타이머 또는 예기치 않은 작동을 방지하기 위해 정리해야하는 리소스를 설정할 때 유용함. 정리 기능은 페이지에서 컴포넌트 자체를 제거( 또는 mount 해제)한 후에도 실행 됨(현재 우리 수준에선 적용x)

Counter3.jsx 생성

```jsx
import { useEffect, useState } from "react";

function Counter3() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("Hello from useEffect!");
    return () => {
      console.log("clean up function 정리 함수");
    };
  }, [count]);

  return (
    <>
      <p>Counter3 : {count}</p>
      <button onClick={() => setCount((preCount) => preCount + 1)}>증가</button>
    </>
  );
}

export default Counter3;
```

이상과 같은 상태로 실행했을 경우, 최초 렌더링 시에 strictMode로 인해 Hello from useEffect - clean up function - Hello from useEffect가 실행되는 것을 확인할 수 있음.

그 이후에는 버튼을 누를때마다, 정리 함수가 먼저 호출되고, 그 다음 다시 Hello from useEffect가 출력된다는 것을 확인했을 때, 값이 바뀌고 - 정리함수 호출하고 - 다시 컴포넌트를 렌더링하는 시간적 순서가 있다고 볼 수 있음.

### useRef

- 해당 훅은 DOM 노드에 접근하는 데 이용할 수 있는 _변경 가능한 ref 객체_ 를 return.
- 형식 :

```jsx
const ref = useRef(initialValue);
```

useRef()의 return 값은 ref에는 argument로 초기화된 속성이 있음(이상에는 initialValue). 이상의 예제에서는 inputRef 객체를 생성해서 null로 초기화했고, JSX 요소의 ref 속성을 이용하여 ref 객체를 전달했음.
`<input ref={inputRef} />` 부분에 해당함. 그러니까 버튼을 클릭했는데 버튼이 활성화 되는게 아니라 input 창이 활성화된 것이라고 볼 수 있음.
DOM 요소가 뭔말인지 헷갈리면 JavaScript 부분 수업할 때의 DOM 조작과 관련 있음. JavaScript에서 getElementById() 등을 통해서 해당 HTML 요소를 불러왔던 것처럼, useRef(null)인 상태에서 ref={inputRef}를 통해 앞으로 input 창을 참조하라고 재대입을 해줬다고 생각하면 그나마 이해하기 편함.
이제 input 요소가 button 요소 내 callback 함수에 포함되고, current 속성을 이용하여, input 요소의 focus 함수를 호출하는 것이 가능(`<button onClick={() => inputRef.current.focus()}>`에 해당하는 부분)

그래서 버튼 눌렀을 때 버튼이 활성화 되는 것이 아니라 input 요소가 활성화됨.

### Custom Hook

React에서는 사용자 정의 Hook 함수를 정의할 수 있음. 원칙에서 나온 것처럼 use로 시작해야하며, 기본적으로는 JavaScript 함수. 마찬가지로 Custom Hook 내에서 다른 Hook을 호출하는 것도 가능. 얘를 쓰면 컴포넌트 내에서의 코드의 복잡성을 줄일 수 있다.

1. useTitle.js 파일 생성
2. Counter4.jsx 파일 생성
```js
import { useEffect } from "react";

// document.title은 index.html 파일의 title을 의미
// title의 값이 바뀔때마다 재대입이 일어남
function useTitle(title) {
  useEffect(() => { document.title = title;}, [title])
}

export default useTitle;
```

```jsx
import { useState } from "react";
import useTitle from "./useTitle";

function Counter4() {
  const [count, setCount] = useState(0);
  useTitle(`당신은 ${count} 번 클릭했습니다 !`);

  return (
    <>
      <p> Counter : {count}</p>
      <br />
      <br />
      <button onClick={() => setCount((prevCount) => prevCount + 1)}>
        증가
      </button>
    </>
  );
}

export default Counter4;
```

## Context API

1. 새 vite project를 만든다.
2. 프로젝트 명은 mycontextapi / framework는 react / language는 Javascript
3. github에 push
  - 잘못 push하면 myapp이 날라가고 mycontext만 올라가는 문제가 생길 수 있음.
  - 어떻게 해야했는지 생각
4. default screen을 띄움
5. title을 'ContextAPI 학습' 으로 고침
